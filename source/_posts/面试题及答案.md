---
title: java面试题
description: java面试题及答案
data: 2023-2-13
updata: 2021-3-1
tags: 
  - java笔记
categories:
  - java
---

### 一、java面向对象有哪些特征？1

面向对象三大特征：**封装、继承、多态**。封装说明一个类行为和属性于其他类的关系，低耦合、高内聚；继承是父类和子类的关系；多态说的是类与类的关系；

**封装**隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对于外界，他的内部细节是隐藏的，暴露的只是他的访问方法。**属性的封装：**使用者只能通过事先制定好的方法来访问数据，可以方便加入逻辑控制，限制对属性的不合理操作；**方法的封装**：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用，增强代码的可维护性；

**继承**是从已有的类中派生出新的类，新的类的数据属性和行为，并能扩展新的能力。子类继承父类，表示子类是一种特殊的父类，并且具有父类所没有的一些方法和属性。从多种实现类中抽出一个基类，使其具备多种实现类的共同特性，当实现类用extends继承了基类（父类）后，实现类就具备了那些相同的属性。当然，父类中通过private定义的变量和方法不会被继承。

对于**多态**，我更倾向于分为**静态多态**和**动态多态**，静态多态是指在编译时就已经确定的多态，常见的就是**重载**，重载是指两个或者多个函数具有形同的函数名，但参数列表不同，这样就可以根据参数据的不同来区分不同的参数。动态多态是指在运行时才能确定的多态，常见的就是**重写**，重写就是子类重新定义父类的方法，从而使父类方法可以根据不同的对象而具有不同的表达。



### 二、java中有哪几种方式来创建线程执行任务？

1. #### 继承thread类

   重写run方法，new thread方法跑。但是这样占用了当前类的继承名额，使得当前类不能再继承其他类  

2. #### 实现runnable接口

   实现run方法，使用依然用到thread。这种方法更常用，其实thread类底层也是实现了runnable接口。

   也可以通过匿名内部类的方式去生成一个runnable对象

   ```java
   Thread thread = new Thread(new Runnable(){
     public void run(){
       System.out.println("hello world")
     }
   })
   ```

   又因为runnable是一个函数式接口（只有一个方法），所以也可以用lamda表达式

   ```java
   Thread thread = new Thread(() -> System.out.println("hello world"))
   ```

3. #### 实现callable接口

   他去执行任务可以拿到任务结果，不过底层也是Runnable

   *实现Runnable生成对象 => 传给FutureTask => 把FutureTask传给Thread => 启动线程 =>FutureTask用get()方法阻塞式取得结果*

   *顺带一提，FutureTask也是实现了Runnable*

4. #### 线程池

   底层还是Runnable，从某种层面上来说，全是用Runnable来做的





### 三、为什么不建议使用Executors来创建线程池

Executors创建线程池底层采用的是无界阻塞队列，当线程数一定但是任务很多时，会将任务不断的塞入队列中，直到耗尽内存导致**OOM**（内存溢出）

而且Executors也不能自定义线程的名字，不利于监控线程和排查问题。更建议使用**ThreadPoolExecutor**，他可以灵活控制线程



### 四、线程池有哪几种状态？分别表示什么？

1. #### RUNNING

   表示线程池正常运行，**既能接受新任务，也可以处理队列中的任务**

2. #### SHUTDOWN

   当调用线程池的**shutdown()**方法时，线程池就会进入SHUTDOWN状态。**此时线程池不会接受新的任务，但是会把队列中的任务处理完**

3. #### STOP

   当调用线程池中的**shutdownnow()**方法时，线程池就会进入STOP状态（停止状态），**此状态下，线程池既不会接受新任务，也不会处理队列中的任务，并且正在运行的线程也会直接中断**

4. #### TIDYING

   线程池中没有线程运行后，线程池的状态会自动进入TIDYING，并调用**terminated()**方法，该方法为空方法，可以进行扩展

5. #### TERMINATED

   terminated()方法执行完后，状态也成了TERMINATED



### 五、Sychronized和ReentrantLock有哪些不同？

|   sychronized   |    ReentrantLock    |
| :-------------: | :-----------------: |
|    java中的关键字    |      JDK提供的一个类      |
|    自动加锁与释放锁     |      需手动加锁与释放锁      |
|     JVM层面的锁     |       API层面的锁       |
| 锁的是对象，信息保存在对象头中 | int类型的state标识标识锁的状态 |
|    底层有锁升级过程     |       无锁升级过程        |
|      非公平锁       |      非公平锁或公平锁       |



### 六、ThreadLocal有哪些场景？底层是如何实现的？

1. ThreadLocal是java中提出的线程本地储存机制，可以利用该机制**将数据缓存在某个线程内**，该线程可随时采用任意方法获取缓存的线程
2. ThreadLocal底层通过ThreadLocalMap来实现的，每个**Thread对象**（不是ThreadLocal对象）都存在一个ThreadLocalMap中，Map的key是ThreadLocal对象，value是需要缓存的值
3. 特别注意，如果在线程池中使用ThreadLocal会导致**内存泄漏**，因为当ThreadLocal对象使用完后，应把设置的key、value即Entry对象回收，但线程池中的线程没有回收，且线程对象是通过强引用指向ThreadLocalMap，而ThreadLocalMap也是通过强引用指向Entry对象。线程没有回收就代表Entry对象没有回收，从而导致内存泄漏。**解决方法：**在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove()方法手动消除Entry对象
4. TreadLocal常用于连接管理，不太常用





### 七、ReentrantLock分为公平锁和非公平锁，底层是如何实现的？

首先，无论公平锁还是非公平锁，他们的底层都是使用AQS来进行排队，他们的区别在于线程使用lock()方法加锁时

1. 如果是公平锁，会先检车AQS队列中是否存在线程在排队，如果有就也进行排队
2. 如果是非公平锁，则不会检查是否有线程排队，而是直接去竞争

此外，无论是非公平锁还是公平锁，一旦没拿到锁，都会进行排队，当释放锁时，都是唤醒最前面的线程。所以非公平锁只是体现在线程加锁阶段，而没有体现在唤醒阶段。**ReentrantLock也是可重入锁，不论是公平还是非公平，都是可重入锁**（即同一个线程可连续重复加同一把锁）



### 八、Sychronized的锁升级过程

1. **偏向锁：**在锁对象的对象头中记录下当前获取到该锁的线程ID，该线程下次如果又来获取，该锁就可以直接被获取，也就是支持锁重入
2. **轻量级锁：**由偏向锁升级而来，当一个线程获取到锁后，此时这把锁就是偏向锁。但是此时如果有第二把锁来竞争，偏向锁就会升级为轻量级锁。之所以叫轻量级锁，就是为了和重量级锁区分开来。轻量级锁的底层是通过自旋来实现的，不会阻塞线程
3. 如果自旋次数过多却仍然没获得锁，则会升级为重量级锁，重量级锁会导致线程阻塞
4. **自旋锁：**当一个线程尝试获取某个锁时，如果该锁被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或者睡眠状态。具体就是通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取。如果获取到了，则表示获取到这个锁。**自旋锁不会阻塞线程**



### 九、Tomcat为什么要使用自定义类加载器

### 十、JDK、JRE、JVM之间的区别

1. JDK是JAVA标准开发包，提供了编译运行java程序所需的各种工具（比如编译器javac）和资源
2. JRE是java运行环境，用于运行java字节码文件（.class），JRE包括JVM和JVM工作所需类库。普通用户只需要安装JRE跑程序，开发者则需要JDK来编译调试
3. JVM是java虚拟机，JRE的一部分，是整个java实现跨平台的关键，负责运行字节码文件



### 十一、String、StringBuffer、StringBuild的区别

**string**是常量，不可变，如果尝试修改string，会新生成一个字符串对象。**stringbuffer**和**stringbuilder**可修改，但是stringbuffer是线程安全的，stringbuilder线程不安全，底层没有锁机制，但是速度相对更快



### 十二、泛型中extends和super的区别

1. **<? extends T>** 表示包括T在内的任何T的子类
2. **<? super T>** 表示包括T在内的任何T的父类



### 十三、 ==和equals方法的区别

1. **==：**如果是基本数据类型，比较的是值；如果是引用类型，比较的是引用地址
2. **equals：**一般情况下和==没区别，他的底层就是==。但是在一些类中被重写了，比如string，虽然是引用类，但是比较的却是每个字符是否相等



### 十四、重载和重写的区别

1. **重载：**发生在同一个类中，方法名必须相同，参数类型不同、参数个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生于编译时
2. **重写：**发生于父子类中，方法名和参数必须相同，返回值范围不可大于父类，抛出异常的范围不可大于父类，访问修饰符范围大于或等于父类。若父类中该方法被private修饰，则不可被重写



### 十五、Set和List的区别

1. **List：**有序，按对象进入的顺序保存对象，可重复，允许多个null元素对象，可以用迭代器进行遍历，也可以用get(index)来获取指定下标的元素
2. **Set：**无序，不可重复，最多允许一个null元素对象。只可以用迭代器（Iterator）遍历



### 十六、 ArrayList和LinkList的区别

1. 首先底层结构不同，ArrayList采用数组实现，而linkedList采用链表来实现
2. 因此，他们的应用场景不同，ArrayList更适合随机查找，linkedList更适合删除和添加
3. 此外，虽然ArrayList和Linkedlist都实现了List接口，但是Linkedlist还额外实现了Deque接口，所以Linkedlist也可以当队列来使用




### 十七、谈谈ConcurrentHashMap的扩容机制

### 十八、JDK1.7与JDK1.8的区别（详细描述HashMap的变化）

### 十九、HashMap的put方法

### 二十、深拷贝和浅拷贝

### 二十一、HashMap的扩容机制原理

### 二十二、CopyOnWriteArrayList的底层原理

### 二十三、什么是字节码？采用字节码的好处

### 二十四、java的异常体系

### 二十五、什么时候抛出异常？什么时候捕获异常？

### 二十六、Java中有哪些类加载器

### 二十七、类加载器双亲委派模型

### 二十八、JVM中哪些是线程共享区

### 二十九、如何排查JVM问题

### 三十、resource和autowired的区别






# SQL面试题

### 一、什么是分库分表？以及他的应用场景

分库分表是一种数据库技术，它可以将数据库中的数据按照一定的规则进行分割，将数据存储到不同的数据库中，以提高数据库的**性能**和**可用性**。

**应用场景：**

1. 当**数据量**较大时，可以将数据分散到多个数据库中，以提高查询性能；
2. 当**数据库访问量**较大时，可以将数据分散到多个数据库中，以提高访问性能；
3. 当**数据库容量较大**时，可以将数据分散到多个数据库中，以提高存储性能。




### 二、left join和right join的区别

LEFT JOIN和RIGHT JOIN的区别在于连接结果中左表和右表的位置不同。

LEFT JOIN会返回左表中的所有记录，即使右表中没有对应的匹配。如果右表中如果没有对应的匹配，右表的字段将被赋值为NULL。RIGHT JOIN则与之相反。

另外，在大部分数据库系统中，支持使用LEFT JOIN和RIGHT JOIN两种语句，并且两种操作是等价的，所以也可以使用 JOIN 替代LEFT JOIN 或 RIGHT JOIN

### 三、数据库优化

1. **架构优化：** 

   1. **分布式缓存：**性能不够，缓存来凑。我们可以在应用于数据库之间加一个缓存服务，比如Redis。当收到查询请求后，我们先查询缓存，判断缓存中是否有数据，有数据则直接返回给应用，如若没有再查数据库。大大减少了对数据库的访问次数，自然提高了性能。

      但是需要注意引入Redis之后的缓存穿透、缓存击穿和缓存雪崩

   2. **读写分离：**一主多从，读写分离，主动同步。一般来说，当你的应用是读多写少，数据库压力过大，采用读写分离，通过增加数据库量可以线性提升系统**读**性能**

      **主库，提供数据库写服务；从库，提供数据库读能力；主从之间，通过binlog同步数据**

      实施读写分离时，为了保证高可用，需要实现故障的自动转移，主从架构会有潜在主从不一致的问题

   3. **分库分表（水平切分）：**当你的应用业务数据量很大，单库容量成为性能瓶颈后，采用水平切分，可以降低数据库单库容量，提升数据库写性能。

      当准备实施水平切分时，需要结合实际业务选取合理的分片键

2. **硬件优化：** 不管是读操作还是写操作，都是要访问磁盘，所以磁盘的性能决定了数据库的性能。用好的就行

3. **DB优化：** SQL执行慢有时候不一定完全是SQL问题，手动安装一台数据库而不做任何参数调整，再怎么优化SQL都无法让其性能最大化。

   基本遵循以下三点：日志不能小、缓存足够大、连接要够用

4. **SQL优化：**

   1. **合理使用索引:**

      索引少了查询慢；索引多了占用空间大，执行增删改语句的时候需要动态维护索引，影响性能

   2. **使用UNION ALL替代UNION：**

      UNION ALL的执行效率比UNION高，因为UNION执行时需要排重；

   3. **避免使用select :**

      执行SQL时优化器需要将 * 转成具体的列；每次查询都要回表，不能走覆盖索引。

   4. **JOIN字段建立索引**

   5. **避免复杂的SQL语句:**

      提升可阅读性；避免慢查询的概率；可以转换成多个短查询，用业务端处理

   6. **避免where 1= 1写法**

   7. **避免order by rand()类似写法:**

      RAND()导致数据列被多次扫描


### 四、**怎么进行去重查询？**

1. **distinct：**效率较低。不适合用来展示去重后具体的值，一般用于计算

   ```sql
   -- 列出 task_id 的所有唯一值（去重后的记录）
   -- select distinct task_id
   -- from Task;

   -- 任务总数
   select count(distinct task_id) task_num
   from Task;
   ```

   ​

2. **group by ：**

   ```sql
   -- 列出 task_id 的所有唯一值（去重后的记录,null也是值）
   -- select task_id
   -- from Task
   -- group by task_id;

   -- 任务总数
   select count(task_id) task_num
   from (select task_id
         from Task
         group by task_id) tmp;

   ```

   ​

3. **row_number：**窗口函数，用的比较少，因为必须先支持窗口函数才行

   ```sql
   -- 在支持窗口函数的 sql 中使用
   select count(case when rn=1 then task_id else null end) task_num
   from (select task_id
   	      , row_number() over (partition by task_id order by start_time) rn
   	  from Task) tmp;

   ```

   ​

